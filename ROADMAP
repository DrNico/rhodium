ROADMAP

Phase 0: ÂµRhodium
+ (micro)   interpreter for simply-typed arrow calculus

Phase 1: the Strap
- (strap)   improved parser with: location, layout rules, error reports
- (strap)   type system: dependent types, with skeleton for Homotopy Types in the future
- (kernel)  develop a crude memory model (unique pointers, all copying is deep)
- (strap)   generate LLVM code

Phase 2: the Boot
- (core)    develop a core library: basic data-types, parsing, etc.
- (boot)    foreign-function interface
- (boot)    re-write the strap in Rhodium, have it compiled by boot

Phase 3: the Bootstrap
- (rhc-bs)  

Phase 4: the Rhodium compiler
- (rhc)     memory management, garbage collection

Parser suggestion:
The new parser should parse new-style definitions such as

#define even
    Zero >- even -> True
    Succ(x) >- even -> r :=
        x >- odd -> r

Some definitions:
  * *strap* The initial tool transforming Rhodium code into LLVM code for compilation. The strap is written in Haskell. It may use some source code from the kernel as a library.
  * *boot* The minimum Rhodium code required to parse and compile other Rhodium code into LLVM. The boot does essentially the same thing as strap, but is written in Rhodium source language.
  * *kernel* The library, used by both strap and boot tools, written in Rhodium, providing the basic functionality for compiling and interpreting Rhodium code. The strap is the first instance transforming the source code of the kernel into an actual linkable library. The boot links against that library.
  * *make* Building sequences are triggered by the invocation of the make tool.
  * *core* The Rhodium standard library.

Type System:
At the core, the type system is based on Contextual Categories, where Objects are contexts and Morphisms are typed terms. On top of that lies a category of Judgments. The system is a faithful implementation of the concepts laid out in arxiv:1211.2851v2.

TODO
+ objects, morphisms, composition in C
+ projections, pullbacks
- dependent function, dependent pair, one, zero, sum types
- judgmental equality
- Check monad, validating all objects at injection
- type-check from source language